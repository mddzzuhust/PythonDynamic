#1. 大傻： 只搬动一号盘
#2. 1. 叫谁来做，： 1. 从哪个柱子搬动到哪个柱子，中间柱子
#2. 2. 搬动自己负责的柱子 3. 从哪个柱子搬动到哪个柱子，中间柱子


def move(index, start, mid, end):
    if index == 1:
        print("{}-->{}".format(start,end))
        return
    else:
        move(index-1, start, end, mid)
        print("{}-->{}".format(start, end))
        move(index-1, mid, start, end)


if __name__ == "__main__":
    move(5, "A", "B", "C")

"""
优点：
    简单，回溯法
    递归都能通过非递归的方式完成
缺点：
    1. 递归由于是函数调用自身，而函数调用是有时间和空间的消耗的：
    每一次函数调用，都需要在内存栈中分配空间以保存参数、返回地址以及临时变量，而往栈中压入数据和弹出数据都需要时间。->效率
    2. 递归中很多计算都是重复的，由于其本质是把一个问题分解成两个或者多个小问题，
    多个小问题存在相互重叠的部分，则存在重复计算，如fibonacci斐波那契数列的递归实现。->效率
    3. 调用栈可能会溢出，其实每一次函数调用会在内存栈中分配空间，而每个进程的栈的容量是有限的，当调用的层次太多时，就会超出栈的容量，从而导致栈溢出。->性能
"""